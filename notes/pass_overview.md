# Mod Analysis:

**Idea** : The basic idea behind mod analysis is to infer the mod value of the final operation based on the knowledge of mod value of operands. 

So suppose if we know the value of (mod a) and (mod b) then we can successfully infer the value of mod(a+b) which will be ((mod a) + (mod b) % mod_base) where mod_base is the value for calculating the mod value.

## Implementation:

### Where in souper
For implementing this pass we have made use of the souper-check. Inside the tools/super-check.cpp, souper creates a pruning object for implementing the dataflow pruning part. This object is initialized using the init method. 

Inside the init method, it also generates concrete values for vars for concrete interpretation of the program. It then applies its dataflow checks to verify the values of vars are valid, and rejects the invalid ones. It then applies concrete interpretation for the remaining values.

isInfeasible is the method souper uses to prune the candidates based on all dataflow pruning techniques such as concrete interpretation, known bits, demanded bits. We implement the mod analysis here where it has tried other data flow techniques to prune the candidates and has failed to do so.

Lines 373-376 in souper-check.cpp


### Mod Analysis
Mod Analysis consists of lib/infer/ModAnalysis.cpp file and include/Infer/ModAnalysis.h file. 
Mod analysis uses the set of valid inputs that is generated during the concrete interpretation of the vars during the init and find the max value among those to take the mod base.

After getting the mod base, it uses a recursive function FindModVal to compute the mod value of the given instruction, if it could. If it cannot infer the mod values for any set of instructions, it just throws a negative value to indicate that mod value cannot be inferred.

The cases where we found candidates that are only pruned by mod analysis and not by souper’s dataflow analysis is in test/Infer/pruning/modprune.opt. There are also a lot of test cases in test/Infer/testset.opt that could be used for testing of pruning.


## Phisets for inferring concrete values
**Idea** : If we have a phinode, we can create a set for concretely interpreting the values of the node to which the phinode is assigned to. For example:
```
%0 = block 3
%1:i32 = var
%2:i32 = phi %0, 0:i32, 15:i32, %1
```


In the above example, we can represent %2 as a set of values and then use concrete interpretation for all of those values and then compare it with the candidate.

Although souper already does some form of concrete interpretation for the phi nodes, it doesn’t let us use phi nodes in the RHS.

## Challenges
We cannot infer anything about the comparisons based on the value of mod for the operands.
Souper doesn’t generate candidates that have all values as holes(not concrete). So pruning techniques shouldn’t be based on those candidates that are never being generated.
## Future Work
Adding phi sets to infer value of phi nodes in the RHS. Currently souper doesn’t infer anything if it finds the phi node in the RHS and throws LLVM error. We can use concrete interpretation for interpreting the set of values for the RHS and compare them with LHS.
Testing on candidates that are actually generated by souper should be the way to test it as there are a bunch of cases where souper doesn't actually generate the candidate that we are looking to prune.


# Input Selection

**Problem**: In cases where the LHS and/or the RHS are the result of a comparison instruction, specifically Eq, and Ne, Concrete Interpretation (CI) can easily fail if it doesn’t have a specific input.

For example the, specification-candidate pair below can only be pruned by CI if given inputs 6 or 8
```
%0:i32 = var
%1:i32 = add %0, 4:i32
%2:i1 = eq 10:i32, %1
infer %2
%3:i1 = eq %1, 12:i32
result %3
```
## Inputs for CI

By default 15 Inputs are generated.

(1-5) Special Inputs (1,0,-1,MAX,MIN)

(6-10) Big Random Inputs

(11-15) Small Random Inputs

Input Selection overrides random inputs with chosen inputs, and does so right before PruningManager is initialized in souper-check

## Implementation

It’s implemented in the dataflow_input_selection branch in include/souper/Infer/InputSelect.cpp

It’s a simple recursive approach that takes advantage of Soupers tree structure. It derives constants starting at comparisons and then reverses arithmetic operations on the way to variable nodes. 

## Things to Add

Relationships between multiple variables, for example telling CI to make all input variables equal
Attempt to run Input Select on LHS and RHS since currently it only uses the RHS. Remember, candidates are always very simple, so this most likely won’t help much
